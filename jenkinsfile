// File: Jenkinsfile (The Professional Docker Agent Version)

pipeline {
    // THIS IS THE KEY CHANGE. We are defining our build agent.
    agent {
        // We specify we want a Docker agent.
        docker {
            // The image to use for our build environment. 'docker:dind' (Docker-in-Docker)
            // is a common choice, or we can use a simpler one. Let's start with a basic image.
            image 'docker:latest'
            
            // This argument is crucial. It mounts the host's Docker socket
            // into our agent container, solving the "permission denied" error.
            args '-v /var/run/docker.sock:/var/run/docker.sock'
        }
    }

    stages {
        stage('1. Verify Docker Environment') {
            steps {
                echo "--- Running inside a Docker container agent ---"
                
                // Let's verify our environment inside the new container.
                sh 'docker --version'
                sh 'docker info' // This will show we can connect to the daemon.
            }
        }

        stage('2. Build Application Image') {
            steps {
                echo "--- Starting Application Docker Image Build ---"
                
                // Because our agent IS a Docker container with the client,
                // we can just use the 'docker' command directly.
                sh "docker build -t my-webapp:${env.BUILD_NUMBER} ."
            }
        }

        stage('3. Verify Build') {
            steps {
                echo "--- Listing images to confirm build success ---"
                sh "docker images"
            }
        }
    }
}