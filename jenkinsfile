// File: Jenkinsfile (The Final, Correct Version)

pipeline {
    // THIS IS THE KEY: Define the agent as 'none' at the top level.
    // This tells Jenkins not to grab an agent until we specify one in a stage.
    // However, for this to work, we will apply tools and agent to all stages.
    
    // Let's simplify. We apply the tools and agent to the whole pipeline.

    // 1. First, prepare the necessary tools for the ENTIRE pipeline.
    tools {
        dockerTool 'default-docker'
    }

    // 2. NOW, define the agent. Jenkins will use the tool above to start this agent.
    agent {
        docker {
            image 'python:3.9-slim'
            // This argument is crucial. It mounts the host's Docker socket
            // into our agent container, solving the "cannot connect" error.
            args '-v /var/run/docker.sock:/var/run/docker.sock'
            reuseNode true
        }
    }

    environment {
        IMAGE_NAME = "my-webapp"
    }

    stages {
        stage('1. Build Docker Image') {
            steps {
                echo "--- Now running inside a python:3.9-slim container ---"
                echo "--- Starting Docker Image Build ---"

                // This 'docker' command is now executed from WITHIN our python agent container,
                // but it communicates to the HOST's docker daemon via the mounted socket.
                sh "docker build -t ${env.IMAGE_NAME}:${env.BUILD_NUMBER} ."

                echo "--- Docker Image Build Complete ---"
            }
        }

        stage('2. Verify Image') {
            steps {
                echo "Listing Docker images on the HOST to verify our build..."
                sh "docker images"
            }
        }
    }
}